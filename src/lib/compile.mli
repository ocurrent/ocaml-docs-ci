(** Compilation step

The documentation compilation is done as an ocluster. It takes for input one prep/ folder and its
compiled dependencies. It uses `voodoo-do` to perform the compilation, link and html generation 
steps, outputting the results in the compile/ and html/ folders.  
*)

type t
(** A compiled package *)

val digest : t -> string
(** String representing the compiled package *)

val artifacts_digest : t -> string
(** Hash of the compiled artifacts (the compile/ folder) *)

val is_blessed : t -> bool
(** A blessed package is compiled in the compile/packages/... hierarchy, whereas a non-blessed 
 package is compiled in the compile/universes/... hierarchy *)

val package : t -> Package.t
(** The compiled package *)

val folder : t -> Fpath.t
(** 
The location where the package is compiled: 
 - If blessed, it's compile/packages/<name>/<version>/
 - If not, it's compile/universes/<universe id>/<name>/<version>/ *)

val odoc : t -> Mld.Gen.odoc_dyn
(** The documentation entry point of the package. It's supposed to be generated by voodoo-do. *)

val v :
  config:Config.t ->
  voodoo:Voodoo.Do.t Current.t ->
  cache:Remote_cache.t Current.t ->
  blessed:Package.Blessed.t Current.t ->
  deps:t list Current.t ->
  Prep.t Current.t ->
  t Current.t
(** [v ~voodoo ~cache ~blessed ~deps prep] is the ocurrent component in charge of building [prep],
using the previously-compiled [deps]. [blessed] contains the information to figure out if [prep] is
a blessed package or not. [cache] contains the artifacts cache metadata to track eventual changes.
[voodoo] is the voodoo-do tool tracker. 

Notably, if compilation artifacts already exists, then the job is a no-op. 
*)

module Pool : sig

  type compile = t

  type t

  val v : unit -> t

  val update : t -> Package.t -> compile Current_term.Output.t -> unit 

end

module Monitor : sig 

  val v : Pool.t -> Prep.t Current.t -> t list Current.t

end